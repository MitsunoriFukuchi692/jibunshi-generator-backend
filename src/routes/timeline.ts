import { Router, Request, Response } from 'express';
import { getDb } from '../db.js';
import { verifyToken, extractToken } from '../utils/auth.js';

const router = Router();

// ============================================
// èªè¨¼ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢
// ============================================
const authenticate = (req: Request, res: Response, next: Function) => {
  const authHeader = req.headers.authorization;
  const token = extractToken(authHeader);

  console.log('ğŸ” Authentication check - Header:', authHeader);

  if (!token) {
    console.error('âŒ No token found');
    return res.status(401).json({ error: 'èªè¨¼ãŒå¿…è¦ã§ã™ã€‚ãƒˆãƒ¼ã‚¯ãƒ³ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚' });
  }

  const decoded = verifyToken(token);
  if (!decoded) {
    console.error('âŒ Token verification failed');
    return res.status(401).json({ error: 'ç„¡åŠ¹ã¾ãŸã¯æœŸé™åˆ‡ã‚Œã®ãƒˆãƒ¼ã‚¯ãƒ³ã§ã™ã€‚' });
  }

  console.log('âœ… Token verified - userId:', decoded.userId);
  (req as any).user = decoded;
  next();
};

// ============================================
// GET /api/timeline - timeline ä¸€è¦§å–å¾—ï¼ˆèªè¨¼å¿…é ˆï¼‰
// ============================================
router.get('/', authenticate, (req: Request, res: Response) => {
  try {
    const { stage, autoGenerated } = req.query;
    const user = (req as any).user;
    const db = getDb();

    console.log('ğŸ“– Timeline list request - user_id:', user.userId, 'autoGenerated:', autoGenerated);

    let query = 'SELECT * FROM timeline WHERE user_id = ?';
    const params: any[] = [user.userId];

    // autoGenerated=true ã®å ´åˆã€AIç”Ÿæˆè‡ªåˆ†å²ã®ã¿ã‚’å–å¾—
    if (autoGenerated === 'true') {
      query += ' AND is_auto_generated = 1';
      console.log('ğŸ¤– Filtering for AI-generated timelines only');
    }

    if (stage) {
      query += ' AND stage = ?';
      params.push(stage);
    }

    query += ' ORDER BY created_at DESC';
    const stmt = db.prepare(query);
    const timelines = stmt.all(...params) as any[];

    console.log('âœ… Timeline list:', timelines.length, 'items');
    res.json(timelines);
  } catch (error: any) {
    console.error('âŒ Error:', error);
    res.status(500).json({ error: error.message });
  }
});

// ============================================
// POST /api/timeline - timeline ä½œæˆï¼ˆèªè¨¼å¿…é ˆï¼‰
// ============================================
router.post('/', authenticate, (req: Request, res: Response) => {
  try {
    const user = (req as any).user;
    const db = getDb();
    const { age, year, month, turning_point, stage, event_title, event_description, edited_content, answersWithPhotos, isAutoGenerated } = req.body;

    console.log('ğŸ’¾ Timeline creation request:', {
      userId: user.userId,
      eventTitle: event_title,
      hasEditedContent: !!edited_content,
      contentLength: edited_content?.length || 0,
      isAutoGenerated: isAutoGenerated
    });

    // å¿…é ˆãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®æ¤œè¨¼
    if (!event_title) {
      console.warn('âš ï¸ Missing event_title');
      return res.status(400).json({
        error: 'event_title is required',
      });
    }

    if (!event_description && !edited_content) {
      console.warn('âš ï¸ Missing both event_description and edited_content');
      return res.status(400).json({
        error: 'Either event_description or edited_content is required',
      });
    }

    // timeline ãƒ†ãƒ¼ãƒ–ãƒ«ã«ä¿å­˜
    const stmt = db.prepare(
      `INSERT INTO timeline (user_id, age, year, month, turning_point, stage, event_title, event_description, edited_content, is_auto_generated)
       VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`
    );

    const result = stmt.run(
      user.userId,
      age ? parseInt(age) : null,
      year ? parseInt(year) : null,
      month ? parseInt(month) : null,
      turning_point || null,
      stage || 'interview',
      event_title,
      event_description || null,
      edited_content || null,
      isAutoGenerated ? 1 : 0  // is_auto_generated: AIç”Ÿæˆã‹ã©ã†ã‹
    );

    const timelineId = result.lastInsertRowid;
    console.log('âœ… Timeline created successfully - id:', timelineId, 'isAutoGenerated:', isAutoGenerated);

    // å†™çœŸãƒ‡ãƒ¼ã‚¿ã‚’ä¿å­˜ï¼ˆbase64 ãƒ‡ãƒ¼ã‚¿ã‚’ç›´æ¥ä¿å­˜ï¼‰
    if (answersWithPhotos && Array.isArray(answersWithPhotos)) {
      try {
        const photoStmt = db.prepare(
          `INSERT INTO timeline_photos (timeline_id, file_path, description, display_order, created_at)
           VALUES (?, ?, ?, ?, datetime('now'))`
        );

        let photoCount = 0;
        for (let idx = 0; idx < answersWithPhotos.length; idx++) {
          const answer = answersWithPhotos[idx];
          if (answer.photos && Array.isArray(answer.photos) && answer.photos.length > 0) {
            console.log('ğŸ“¸ Processing answer', idx, '- photo count:', answer.photos.length);
            
            for (let photoIdx = 0; photoIdx < answer.photos.length; photoIdx++) {
              const photo = answer.photos[photoIdx];
              
              console.log('ğŸ“¸ Saving photo:', {
                timelineId,
                answerIdx: idx,
                photoIdx,
                hasFilePath: !!photo.file_path,
                filePathLength: photo.file_path?.length || 0,
                description: photo.description
              });

              photoStmt.run(
                timelineId,
                photo.file_path,  // base64 ã¾ãŸã¯ URL ãƒ‘ã‚¹
                photo.description || `Photo from Q${idx + 1}`,
                photoCount
              );
              photoCount++;
              console.log('âœ… Photo saved - count:', photoCount, '- description:', photo.description);
            }
          }
        }
        console.log('âœ… All photos saved - total:', photoCount, 'for timeline id:', timelineId);
      } catch (photoError: any) {
        console.error('âŒ Photo save error:', photoError);
        console.error('âŒ Error details:', photoError.message, photoError.stack);
        console.warn('âš ï¸ Photo save warning:', photoError.message);
        // å†™çœŸä¿å­˜ã‚¨ãƒ©ãƒ¼ã¯ç„¡è¦–ã—ã¦ç¶šè¡Œ
      }
    }

    // ä¿å­˜ã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ã—ã¦è¿”ã™
    const savedTimeline = db.prepare('SELECT * FROM timeline WHERE id = ?').get(timelineId);

    res.status(201).json({
      success: true,
      message: 'Timeline created successfully',
      data: savedTimeline
    });

  } catch (error: any) {
    console.error('âŒ Error in POST /api/timeline:', error);
    res.status(500).json({ 
      error: 'Failed to create timeline',
      details: error.message 
    });
  }
});

// ============================================
// GET /api/timeline/:id - ç‰¹å®šã® timeline å–å¾—ï¼ˆèªè¨¼å¿…é ˆï¼‰
// ============================================
router.get('/:id', authenticate, (req: Request, res: Response) => {
  try {
    const { id } = req.params;
    const user = (req as any).user;
    const db = getDb();

    console.log('ğŸ“– Timeline detail request - id:', id);

    const stmt = db.prepare('SELECT * FROM timeline WHERE id = ? AND user_id = ?');
    const timeline = stmt.get(id, user.userId);

    if (!timeline) {
      console.warn('âš ï¸ Timeline not found - id:', id);
      return res.status(404).json({ error: 'Timeline not found' });
    }

    console.log('âœ… Timeline retrieved - id:', id);
    res.json(timeline);
  } catch (error: any) {
    console.error('âŒ Error:', error);
    res.status(500).json({ error: error.message });
  }
});

// ============================================
// PUT /api/timeline/:id - timeline æ›´æ–°ï¼ˆèªè¨¼å¿…é ˆï¼‰
// ============================================
router.put('/:id', authenticate, (req: Request, res: Response) => {
  try {
    const { id } = req.params;
    const user = (req as any).user;
    const db = getDb();
    const { age, year, month, turning_point, stage, event_title, event_description, edited_content } = req.body;

    console.log('âœï¸ Timeline update request - id:', id);

    // æœ¬äººç¢ºèª
    const timeline = db.prepare('SELECT user_id FROM timeline WHERE id = ?').get(id) as any;
    if (!timeline) {
      console.warn('âš ï¸ Timeline not found - id:', id);
      return res.status(404).json({ error: 'Timeline not found' });
    }

    if (timeline.user_id !== user.userId) {
      console.error('âŒ Access denied');
      return res.status(403).json({ error: 'ã‚¢ã‚¯ã‚»ã‚¹æ¨©é™ãŒã‚ã‚Šã¾ã›ã‚“ã€‚' });
    }

    const stmt = db.prepare(
      `UPDATE timeline
       SET age = COALESCE(?, age),
           year = COALESCE(?, year),
           month = COALESCE(?, month),
           turning_point = COALESCE(?, turning_point),
           stage = COALESCE(?, stage),
           event_title = COALESCE(?, event_title),
           event_description = COALESCE(?, event_description),
           edited_content = COALESCE(?, edited_content),
           updated_at = datetime('now')
       WHERE id = ?`
    );

    stmt.run(
      age ? parseInt(age) : null,
      year ? parseInt(year) : null,
      month ? parseInt(month) : null,
      turning_point || null,
      stage || null,
      event_title || null,
      event_description || null,
      edited_content || null,
      id
    );

    const updatedTimeline = db.prepare('SELECT * FROM timeline WHERE id = ?').get(id);

    console.log('âœ… Timeline updated successfully - id:', id);
    res.json({ 
      success: true,
      message: 'Timeline updated successfully', 
      data: updatedTimeline 
    });
  } catch (error: any) {
    console.error('âŒ Error:', error);
    res.status(500).json({ error: error.message });
  }
});

// ============================================
// DELETE /api/timeline/:id - timeline å‰Šé™¤ï¼ˆèªè¨¼å¿…é ˆï¼‰
// ============================================
router.delete('/:id', authenticate, (req: Request, res: Response) => {
  try {
    const { id } = req.params;
    const user = (req as any).user;
    const db = getDb();

    console.log('ğŸ—‘ï¸ Timeline delete request - id:', id);

    // æœ¬äººç¢ºèª
    const timeline = db.prepare('SELECT user_id FROM timeline WHERE id = ?').get(id) as any;
    if (!timeline) {
      console.warn('âš ï¸ Timeline not found - id:', id);
      return res.status(404).json({ error: 'Timeline not found' });
    }

    if (timeline.user_id !== user.userId) {
      console.error('âŒ Access denied');
      return res.status(403).json({ error: 'ã‚¢ã‚¯ã‚»ã‚¹æ¨©é™ãŒã‚ã‚Šã¾ã›ã‚“ã€‚' });
    }

    const stmt = db.prepare('DELETE FROM timeline WHERE id = ?');
    stmt.run(id);

    console.log('âœ… Timeline deleted successfully - id:', id);
    res.json({ 
      success: true,
      message: 'Timeline deleted successfully' 
    });
  } catch (error: any) {
    console.error('âŒ Error:', error);
    res.status(500).json({ error: error.message });
  }
});

// ============================================
// ğŸ“¸ å†™çœŸç´ä»˜ã‘é–¢é€£ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ
// ============================================

// GET /api/timeline/:timelineId/photos - ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³ã®ç´ä»˜ãå†™çœŸã‚’å–å¾—
router.get('/:timelineId/photos', authenticate, (req: Request, res: Response) => {
  try {
    const { timelineId } = req.params;
    const user = (req as any).user;
    const db = getDb();

    console.log('ğŸ“¸ Get timeline photos - timelineId:', timelineId);

    // æœ¬äººç¢ºèªï¼ˆã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³ã®æ‰€æœ‰è€…ç¢ºèªï¼‰
    const timeline = db.prepare('SELECT user_id FROM timeline WHERE id = ?').get(timelineId) as any;
    if (!timeline || timeline.user_id !== user.userId) {
      console.error('âŒ Access denied');
      return res.status(403).json({ error: 'ã‚¢ã‚¯ã‚»ã‚¹æ¨©é™ãŒã‚ã‚Šã¾ã›ã‚“ã€‚' });
    }

    // ç´ä»˜ãå†™çœŸã‚’å–å¾—
    const stmt = db.prepare(`
      SELECT id, timeline_id, file_path, description, display_order, created_at
      FROM timeline_photos
      WHERE timeline_id = ?
      ORDER BY display_order ASC, created_at ASC
    `);
    const photos = stmt.all(timelineId);

    console.log('âœ… Found', photos.length, 'photos for timeline:', timelineId);
    res.json(photos);
  } catch (error: any) {
    console.error('âŒ Error:', error);
    res.status(500).json({ error: error.message });
  }
});

// POST /api/timeline/:timelineId/photos - å†™çœŸã‚’ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³ã«ç´ä»˜ã‘ã‚‹
router.post('/:timelineId/photos', authenticate, (req: Request, res: Response) => {
  try {
    const { timelineId } = req.params;
    const user = (req as any).user;
    const db = getDb();
    const { photoIds, photoData } = req.body;

    console.log('ğŸ“¸ Link photos to timeline - timelineId:', timelineId, 'photoCount:', photoIds?.length || photoData?.length);

    // æœ¬äººç¢ºèª
    const timeline = db.prepare('SELECT user_id FROM timeline WHERE id = ?').get(timelineId) as any;
    if (!timeline || timeline.user_id !== user.userId) {
      console.error('âŒ Access denied');
      return res.status(403).json({ error: 'ã‚¢ã‚¯ã‚»ã‚¹æ¨©é™ãŒã‚ã‚Šã¾ã›ã‚“ã€‚' });
    }

    let insertedPhotos: any[] = [];

    // ãƒ‘ã‚¿ãƒ¼ãƒ³1: photo IDs ã§ç´ä»˜ã‘ã‚‹ï¼ˆæ—¢å­˜ã® photos ãƒ†ãƒ¼ãƒ–ãƒ«ã‹ã‚‰å–å¾—ï¼‰
    if (photoIds && Array.isArray(photoIds) && photoIds.length > 0) {
      const photoStmt = db.prepare(`
        SELECT id, file_path, description FROM photos 
        WHERE id = ? AND user_id = ?
      `);

      const insertStmt = db.prepare(`
        INSERT INTO timeline_photos (timeline_id, file_path, description, display_order, created_at)
        VALUES (?, ?, ?, ?, datetime('now'))
      `);

      for (let idx = 0; idx < photoIds.length; idx++) {
        const photoId = photoIds[idx];
        const photo = photoStmt.get(photoId, user.userId) as any;

        if (photo) {
          const result = insertStmt.run(timelineId, photo.file_path, photo.description, idx);
          insertedPhotos.push({
            id: result.lastInsertRowid,
            file_path: photo.file_path,
            description: photo.description,
            display_order: idx
          });
          console.log('âœ… Photo linked - photoId:', photoId, 'timelineId:', timelineId);
        } else {
          console.warn('âš ï¸ Photo not found or not owned by user - photoId:', photoId);
        }
      }
    }

    // ãƒ‘ã‚¿ãƒ¼ãƒ³2: ç›´æ¥å†™çœŸãƒ‡ãƒ¼ã‚¿ã§ç´ä»˜ã‘ã‚‹
    if (photoData && Array.isArray(photoData) && photoData.length > 0) {
      const insertStmt = db.prepare(`
        INSERT INTO timeline_photos (timeline_id, file_path, description, display_order, created_at)
        VALUES (?, ?, ?, ?, datetime('now'))
      `);

      for (let idx = 0; idx < photoData.length; idx++) {
        const photo = photoData[idx];
        const result = insertStmt.run(
          timelineId,
          photo.file_path,
          photo.description || '',
          idx
        );
        insertedPhotos.push({
          id: result.lastInsertRowid,
          file_path: photo.file_path,
          description: photo.description || '',
          display_order: idx
        });
        console.log('âœ… Photo data linked - timelineId:', timelineId);
      }
    }

    res.status(201).json({
      success: true,
      message: `${insertedPhotos.length} photos linked successfully`,
      data: insertedPhotos
    });

  } catch (error: any) {
    console.error('âŒ Error:', error);
    res.status(500).json({ error: error.message });
  }
});

// DELETE /api/timeline/:timelineId/photos/:photoId - ç´ä»˜ãã‚’å‰Šé™¤
router.delete('/:timelineId/photos/:photoId', authenticate, (req: Request, res: Response) => {
  try {
    const { timelineId, photoId } = req.params;
    const user = (req as any).user;
    const db = getDb();

    console.log('ğŸ—‘ï¸ Unlink photo - timelineId:', timelineId, 'photoId:', photoId);

    // æœ¬äººç¢ºèª
    const timeline = db.prepare('SELECT user_id FROM timeline WHERE id = ?').get(timelineId) as any;
    if (!timeline || timeline.user_id !== user.userId) {
      console.error('âŒ Access denied');
      return res.status(403).json({ error: 'ã‚¢ã‚¯ã‚»ã‚¹æ¨©é™ãŒã‚ã‚Šã¾ã›ã‚“ã€‚' });
    }

    const stmt = db.prepare('DELETE FROM timeline_photos WHERE id = ? AND timeline_id = ?');
    stmt.run(photoId, timelineId);

    console.log('âœ… Photo unlinked successfully');
    res.json({
      success: true,
      message: 'Photo unlinked successfully'
    });
  } catch (error: any) {
    console.error('âŒ Error:', error);
    res.status(500).json({ error: error.message });
  }
});

// ============================================
// POST /api/timeline/:timelineId/metadata - timeline_metadata ä½œæˆ
// ============================================
router.post('/:timelineId/metadata', authenticate, (req: Request, res: Response) => {
  try {
    const user = (req as any).user;
    const db = getDb();
    const { timelineId } = req.params;
    const { user_id, important_events, turning_points, custom_metadata } = req.body;

    console.log('ğŸ“Š timeline_metadata creation request:', {
      userId: user.userId,
      timelineId,
      hasImportantEvents: !!important_events,
      hasTurningPoints: !!turning_points
    });

    // user_id ã®æ¤œè¨¼
    if (user_id !== user.userId) {
      console.error('âŒ User ID mismatch');
      return res.status(403).json({ error: 'ã‚¢ã‚¯ã‚»ã‚¹æ¨©é™ãŒã‚ã‚Šã¾ã›ã‚“' });
    }

    // timeline ãŒå­˜åœ¨ã™ã‚‹ã‹ç¢ºèª
    const timeline = db.prepare('SELECT * FROM timeline WHERE id = ? AND user_id = ?').get(timelineId, user.userId) as any;
    if (!timeline) {
      console.error('âŒ Timeline not found');
      return res.status(404).json({ error: 'Timeline ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“' });
    }

    // âœ… timeline_metadata ã«æŒ¿å…¥ï¼ˆæ—¢å­˜ã®å ´åˆã¯ç„¡è¦–ã€æ–°è¦ã®å ´åˆã®ã¿ä½œæˆï¼‰
    try {
      const stmt = db.prepare(`
        INSERT INTO timeline_metadata (
          user_id, 
          timeline_id, 
          important_events, 
          turning_points, 
          custom_metadata, 
          created_at
        ) VALUES (?, ?, ?, ?, ?, datetime('now'))
      `);

      stmt.run(
        user.userId,
        timelineId,
        important_events || '[]',  // JSONæ–‡å­—åˆ—ã¨ã—ã¦ä¿å­˜
        turning_points || '[]',    // JSONæ–‡å­—åˆ—ã¨ã—ã¦ä¿å­˜
        custom_metadata ? JSON.stringify(custom_metadata) : '{}'
      );

      console.log('âœ… timeline_metadata created successfully - timelineId:', timelineId);

      res.json({
        success: true,
        message: 'timeline_metadata created successfully',
        timelineId
      });

    } catch (dbError: any) {
      // UNIQUE åˆ¶ç´„ã«ã‚ˆã‚‹é‡è¤‡ã‚¨ãƒ©ãƒ¼ã®å ´åˆã¯ç„¡è¦–
      if (dbError.message.includes('UNIQUE')) {
        console.log('âš ï¸ timeline_metadata already exists for this timeline');
        return res.json({
          success: true,
          message: 'timeline_metadata already exists',
          timelineId
        });
      }
      throw dbError;
    }

  } catch (error: any) {
    console.error('âŒ Error in POST /api/timeline/:timelineId/metadata:', error);
    res.status(500).json({ 
      error: 'timeline_metadata ä½œæˆã«å¤±æ•—ã—ã¾ã—ãŸ',
      details: error.message 
    });
  }
});

export default router;