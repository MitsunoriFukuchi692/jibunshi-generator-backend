import { Router } from 'express';
import { getDb } from '../db.js';
import { verifyToken, extractToken } from '../utils/auth.js';
const router = Router();
// ============================================
// èªè¨¼ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢
// ============================================
const authenticate = (req, res, next) => {
    const authHeader = req.headers.authorization;
    const token = extractToken(authHeader);
    console.log('ğŸ” Authentication check - Header:', authHeader);
    if (!token) {
        console.error('âŒ No token found');
        return res.status(401).json({ error: 'èªè¨¼ãŒå¿…è¦ã§ã™ã€‚ãƒˆãƒ¼ã‚¯ãƒ³ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚' });
    }
    const decoded = verifyToken(token);
    if (!decoded) {
        console.error('âŒ Token verification failed');
        return res.status(401).json({ error: 'ç„¡åŠ¹ã¾ãŸã¯æœŸé™åˆ‡ã‚Œã®ãƒˆãƒ¼ã‚¯ãƒ³ã§ã™ã€‚' });
    }
    console.log('âœ… Token verified - userId:', decoded.userId);
    req.user = decoded;
    next();
};
// ============================================
// GET /api/timeline - timeline ä¸€è¦§å–å¾—ï¼ˆèªè¨¼å¿…é ˆï¼‰
// ============================================
router.get('/', authenticate, (req, res) => {
    try {
        const { stage, autoGenerated } = req.query;
        const user = req.user;
        const db = getDb();
        console.log('ğŸ“– Timeline list request - user_id:', user.userId, 'autoGenerated:', autoGenerated);
        let query = 'SELECT * FROM timeline WHERE user_id = ?';
        const params = [user.userId];
        // autoGenerated=true ã®å ´åˆã€AIç”Ÿæˆè‡ªåˆ†å²ã®ã¿ã‚’å–å¾—
        if (autoGenerated === 'true') {
            query += ' AND is_auto_generated = 1';
            console.log('ğŸ¤– Filtering for AI-generated timelines only');
        }
        if (stage) {
            query += ' AND stage = ?';
            params.push(stage);
        }
        query += ' ORDER BY created_at DESC';
        const stmt = db.prepare(query);
        const timelines = stmt.all(...params);
        console.log('âœ… Timeline list:', timelines.length, 'items');
        res.json(timelines);
    }
    catch (error) {
        console.error('âŒ Error:', error);
        res.status(500).json({ error: error.message });
    }
});
// ============================================
// POST /api/timeline - timeline ä½œæˆï¼ˆèªè¨¼å¿…é ˆï¼‰
// ============================================
router.post('/', authenticate, (req, res) => {
    try {
        const user = req.user;
        const db = getDb();
        // âœ… ä¿®æ­£1ï¼šyear ã‚’ event_age ã«å¤‰æ›´
        const { age, event_age, month, turning_point, stage, event_title, event_description, edited_content, answersWithPhotos, isAutoGenerated } = req.body;
        console.log('ğŸ’¾ Timeline creation request:', {
            userId: user.userId,
            eventTitle: event_title,
            hasEditedContent: !!edited_content,
            contentLength: edited_content?.length || 0,
            isAutoGenerated: isAutoGenerated,
            eventAge: event_age // âœ… ãƒ­ã‚°ã«è¿½åŠ 
        });
        // å¿…é ˆãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®æ¤œè¨¼
        if (!event_title) {
            console.warn('âš ï¸ Missing event_title');
            return res.status(400).json({
                error: 'event_title is required',
            });
        }
        if (!event_description && !edited_content) {
            console.warn('âš ï¸ Missing both event_description and edited_content');
            return res.status(400).json({
                error: 'Either event_description or edited_content is required',
            });
        }
        // âœ… ä¿®æ­£2ï¼ševent_age ã‹ã‚‰ year ã‚’è¨ˆç®—
        let event_year = null;
        if (event_age !== undefined && event_age !== null) {
            try {
                const userRecord = db.prepare('SELECT birth_year FROM users WHERE id = ?').get(user.userId);
                if (userRecord && userRecord.birth_year) {
                    const ageValue = parseInt(event_age);
                    if (!isNaN(ageValue) && ageValue >= 0 && ageValue <= 150) {
                        event_year = userRecord.birth_year + ageValue;
                        console.log('âœ… Event year calculated:', {
                            birth_year: userRecord.birth_year,
                            event_age: ageValue,
                            event_year: event_year
                        });
                    }
                }
            }
            catch (calcError) {
                console.error('âŒ Error calculating event year:', calcError);
            }
        }
        // timeline ãƒ†ãƒ¼ãƒ–ãƒ«ã«ä¿å­˜
        const stmt = db.prepare(`INSERT INTO timeline (user_id, age, year, month, turning_point, stage, event_title, event_description, edited_content, is_auto_generated)
       VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`);
        const result = stmt.run(user.userId, event_age ? parseInt(event_age) : null, event_year, // âœ… ä¿®æ­£3ï¼šyear ã‚’ event_year ã«å¤‰æ›´
        month ? parseInt(month) : null, turning_point || null, stage || 'interview', event_title, event_description || null, edited_content || null, isAutoGenerated ? 1 : 0 // is_auto_generated: AIç”Ÿæˆã‹ã©ã†ã‹
        );
        const timelineId = result.lastInsertRowid;
        console.log('âœ… Timeline created successfully - id:', timelineId, 'year:', event_year, 'isAutoGenerated:', isAutoGenerated);
        // âœ… ã“ã“ã«è¿½åŠ ï¼šbiography ã«ã‚‚ä¿å­˜
        if (edited_content) {
            const bioStmt = db.prepare(`
    INSERT OR REPLACE INTO biography (user_id, edited_content, ai_summary, updated_at)
    VALUES (?, ?, ?, datetime('now'))
  `);
            bioStmt.run(user.userId, edited_content, edited_content);
            console.log('âœ… Biography saved - user_id:', user.userId);
        }
        // å†™çœŸãƒ‡ãƒ¼ã‚¿ã‚’ä¿å­˜ï¼ˆbase64 ãƒ‡ãƒ¼ã‚¿ã‚’ç›´æ¥ä¿å­˜ï¼‰
        if (answersWithPhotos && Array.isArray(answersWithPhotos)) {
            try {
                const photoStmt = db.prepare(`INSERT INTO timeline_photos (timeline_id, file_path, description, display_order, created_at)
           VALUES (?, ?, ?, ?, datetime('now'))`);
                let photoCount = 0;
                for (let idx = 0; idx < answersWithPhotos.length; idx++) {
                    const answer = answersWithPhotos[idx];
                    if (answer.photos && Array.isArray(answer.photos) && answer.photos.length > 0) {
                        console.log('ğŸ“¸ Processing answer', idx, '- photo count:', answer.photos.length);
                        for (let photoIdx = 0; photoIdx < answer.photos.length; photoIdx++) {
                            const photo = answer.photos[photoIdx];
                            console.log('ğŸ“¸ Saving photo:', {
                                timelineId,
                                answerIdx: idx,
                                photoIdx,
                                hasFilePath: !!photo.file_path,
                                filePathLength: photo.file_path?.length || 0,
                                description: photo.description
                            });
                            photoStmt.run(timelineId, photo.file_path, // base64 ã¾ãŸã¯ URL ãƒ‘ã‚¹
                            photo.description || `Photo from Q${idx + 1}`, photoCount);
                            photoCount++;
                            console.log('âœ… Photo saved - count:', photoCount, '- description:', photo.description);
                        }
                    }
                }
                console.log('âœ… All photos saved - total:', photoCount, 'for timeline id:', timelineId);
            }
            catch (photoError) {
                console.error('âŒ Photo save error:', photoError);
                console.error('âŒ Error details:', photoError.message, photoError.stack);
                console.warn('âš ï¸ Photo save warning:', photoError.message);
                // å†™çœŸä¿å­˜ã‚¨ãƒ©ãƒ¼ã¯ç„¡è¦–ã—ã¦ç¶šè¡Œ
            }
        }
        // ä¿å­˜ã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ã—ã¦è¿”ã™
        const savedTimeline = db.prepare('SELECT * FROM timeline WHERE id = ?').get(timelineId);
        res.status(201).json({
            success: true,
            message: 'Timeline created successfully',
            data: savedTimeline
        });
    }
    catch (error) {
        console.error('âŒ Error in POST /api/timeline:', error);
        res.status(500).json({
            error: 'Failed to create timeline',
            details: error.message
        });
    }
});
// ============================================
// GET /api/timeline/user/:userId - ãƒ¦ãƒ¼ã‚¶ãƒ¼ã® timeline ä¸€è¦§å–å¾—ï¼ˆèªè¨¼å¿…é ˆï¼‰
// ============================================
router.get('/user/:userId', authenticate, (req, res) => {
    try {
        const { userId } = req.params;
        const user = req.user;
        const db = getDb();
        console.log('ğŸ“– Timeline list by userId request - userId:', userId, 'authenticated user:', user.userId);
        // ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯è‡ªåˆ†ã®ãƒ‡ãƒ¼ã‚¿ã®ã¿å–å¾—å¯èƒ½
        if (parseInt(userId) !== user.userId) {
            console.error('âŒ Access denied - userId mismatch');
            return res.status(403).json({ error: 'ã‚¢ã‚¯ã‚»ã‚¹æ¨©é™ãŒã‚ã‚Šã¾ã›ã‚“ã€‚' });
        }
        const stmt = db.prepare(`
      SELECT id, year, month, event_title as eventTitle, event_description as description
      FROM timeline 
      WHERE user_id = ?
      ORDER BY year ASC, month ASC
    `);
        const timelineData = stmt.all(userId);
        console.log('âœ… Timeline list retrieved:', timelineData.length, 'items');
        // ãƒ¬ã‚¹ãƒãƒ³ã‚¹å½¢å¼ã‚’ TimelineListPage.tsx ã«åˆã‚ã›ã‚‹
        res.json({ events: timelineData });
    }
    catch (error) {
        console.error('âŒ Error:', error);
        res.status(500).json({ error: error.message });
    }
});
// ============================================
// GET /api/timeline/:id - ç‰¹å®šã® timeline å–å¾—ï¼ˆèªè¨¼å¿…é ˆï¼‰
// ============================================
router.get('/:id', authenticate, (req, res) => {
    try {
        const { id } = req.params;
        const user = req.user;
        const db = getDb();
        console.log('ğŸ“– Timeline detail request - id:', id);
        const stmt = db.prepare('SELECT * FROM timeline WHERE id = ? AND user_id = ?');
        const timeline = stmt.get(id, user.userId);
        if (!timeline) {
            console.error('âŒ Timeline not found');
            return res.status(404).json({ error: 'Timeline ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚' });
        }
        console.log('âœ… Timeline retrieved - id:', id);
        res.json(timeline);
    }
    catch (error) {
        console.error('âŒ Error:', error);
        res.status(500).json({ error: error.message });
    }
});
// ============================================
// PUT /api/timeline/:id - timeline æ›´æ–°ï¼ˆèªè¨¼å¿…é ˆï¼‰
// ============================================
router.put('/:id', authenticate, (req, res) => {
    try {
        const { id } = req.params;
        const user = req.user;
        const db = getDb();
        const { age, event_age, month, turning_point, stage, event_title, event_description, edited_content, isAutoGenerated } = req.body;
        console.log('âœï¸ Timeline update request - id:', id, 'userId:', user.userId);
        // timeline ãŒå­˜åœ¨ã—ã¦ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ã‚‚ã®ã‹ç¢ºèª
        const timeline = db.prepare('SELECT user_id FROM timeline WHERE id = ?').get(id);
        if (!timeline || timeline.user_id !== user.userId) {
            console.error('âŒ Timeline not found or access denied');
            return res.status(403).json({ error: 'ã‚¢ã‚¯ã‚»ã‚¹æ¨©é™ãŒã‚ã‚Šã¾ã›ã‚“ã€‚' });
        }
        // âœ… ä¿®æ­£ï¼ševent_age ã‹ã‚‰ year ã‚’è¨ˆç®—ï¼ˆPUTæ™‚ã‚‚åŒæ§˜ï¼‰
        let event_year = null;
        if (event_age !== undefined && event_age !== null) {
            try {
                const userRecord = db.prepare('SELECT birth_year FROM users WHERE id = ?').get(user.userId);
                if (userRecord && userRecord.birth_year) {
                    const ageValue = parseInt(event_age);
                    if (!isNaN(ageValue) && ageValue >= 0 && ageValue <= 150) {
                        event_year = userRecord.birth_year + ageValue;
                        console.log('âœ… Event year calculated (UPDATE):', {
                            birth_year: userRecord.birth_year,
                            event_age: ageValue,
                            event_year: event_year
                        });
                    }
                }
            }
            catch (calcError) {
                console.error('âŒ Error calculating event year:', calcError);
            }
        }
        // timeline ã‚’æ›´æ–°
        const stmt = db.prepare(`
      UPDATE timeline 
      SET age = ?, year = ?, month = ?, turning_point = ?, stage = ?, event_title = ?, event_description = ?, edited_content = ?, is_auto_generated = ?, updated_at = datetime('now')
      WHERE id = ? AND user_id = ?
    `);
        stmt.run(event_age ? parseInt(event_age) : null, event_year, // âœ… ä¿®æ­£ï¼šyear ã‚’ event_year ã«å¤‰æ›´
        month ? parseInt(month) : null, turning_point || null, stage || 'interview', event_title, event_description || null, edited_content || null, isAutoGenerated ? 1 : 0, id, user.userId);
        console.log('âœ… Timeline updated - id:', id);
        // æ›´æ–°ã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ã—ã¦è¿”ã™
        const updatedTimeline = db.prepare('SELECT * FROM timeline WHERE id = ?').get(id);
        res.json({
            success: true,
            message: 'Timeline updated successfully',
            data: updatedTimeline
        });
    }
    catch (error) {
        console.error('âŒ Error in PUT /api/timeline/:id:', error);
        res.status(500).json({
            error: 'Failed to update timeline',
            details: error.message
        });
    }
});
// ============================================
// DELETE /api/timeline/:id - timeline å‰Šé™¤ï¼ˆèªè¨¼å¿…é ˆï¼‰
// ============================================
router.delete('/:id', authenticate, (req, res) => {
    try {
        const { id } = req.params;
        const user = req.user;
        const db = getDb();
        console.log('ğŸ—‘ï¸ Timeline delete request - id:', id, 'userId:', user.userId);
        // timeline ãŒå­˜åœ¨ã—ã¦ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ã‚‚ã®ã‹ç¢ºèª
        const timeline = db.prepare('SELECT user_id FROM timeline WHERE id = ?').get(id);
        if (!timeline || timeline.user_id !== user.userId) {
            console.error('âŒ Timeline not found or access denied');
            return res.status(403).json({ error: 'ã‚¢ã‚¯ã‚»ã‚¹æ¨©é™ãŒã‚ã‚Šã¾ã›ã‚“ã€‚' });
        }
        // timeline_photos ã‚‚å‰Šé™¤
        db.prepare('DELETE FROM timeline_photos WHERE timeline_id = ?').run(id);
        // timeline ã‚’å‰Šé™¤
        db.prepare('DELETE FROM timeline WHERE id = ?').run(id);
        console.log('âœ… Timeline deleted - id:', id);
        res.json({
            success: true,
            message: 'Timeline deleted successfully'
        });
    }
    catch (error) {
        console.error('âŒ Error in DELETE /api/timeline/:id:', error);
        res.status(500).json({
            error: 'Failed to delete timeline',
            details: error.message
        });
    }
});
// GET /api/timeline/:timelineId/photos - ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³ã®ç´ä»˜ãå†™çœŸã‚’å–å¾—
router.get('/:timelineId/photos', authenticate, (req, res) => {
    try {
        const { timelineId } = req.params;
        const user = req.user;
        const db = getDb();
        console.log('ğŸ“¸ Get timeline photos - timelineId:', timelineId);
        // æœ¬äººç¢ºèªï¼ˆã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³ã®æ‰€æœ‰è€…ç¢ºèªï¼‰
        const timeline = db.prepare('SELECT user_id FROM timeline WHERE id = ?').get(timelineId);
        if (!timeline || timeline.user_id !== user.userId) {
            console.error('âŒ Access denied');
            return res.status(403).json({ error: 'ã‚¢ã‚¯ã‚»ã‚¹æ¨©é™ãŒã‚ã‚Šã¾ã›ã‚“ã€‚' });
        }
        // ç´ä»˜ãå†™çœŸã‚’å–å¾—
        const stmt = db.prepare(`
      SELECT id, timeline_id, file_path, description, display_order, created_at
      FROM timeline_photos
      WHERE timeline_id = ?
      ORDER BY display_order ASC, created_at ASC
    `);
        const photos = stmt.all(timelineId);
        console.log('âœ… Found', photos.length, 'photos for timeline:', timelineId);
        res.json(photos);
    }
    catch (error) {
        console.error('âŒ Error:', error);
        res.status(500).json({ error: error.message });
    }
});
// POST /api/timeline/:timelineId/photos - å†™çœŸã‚’ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³ã«ç´ä»˜ã‘ã‚‹
router.post('/:timelineId/photos', authenticate, (req, res) => {
    try {
        const { timelineId } = req.params;
        const user = req.user;
        const db = getDb();
        const { photoIds, photoData } = req.body;
        console.log('ğŸ“¸ Link photos to timeline - timelineId:', timelineId, 'photoCount:', photoIds?.length || photoData?.length);
        // æœ¬äººç¢ºèª
        const timeline = db.prepare('SELECT user_id FROM timeline WHERE id = ?').get(timelineId);
        if (!timeline || timeline.user_id !== user.userId) {
            console.error('âŒ Access denied');
            return res.status(403).json({ error: 'ã‚¢ã‚¯ã‚»ã‚¹æ¨©é™ãŒã‚ã‚Šã¾ã›ã‚“ã€‚' });
        }
        let insertedPhotos = [];
        // ãƒ‘ã‚¿ãƒ¼ãƒ³1: photo IDs ã§ç´ä»˜ã‘ã‚‹ï¼ˆæ—¢å­˜ã® photos ãƒ†ãƒ¼ãƒ–ãƒ«ã‹ã‚‰å–å¾—ï¼‰
        if (photoIds && Array.isArray(photoIds) && photoIds.length > 0) {
            const photoStmt = db.prepare(`
        SELECT id, file_path, description FROM photos 
        WHERE id = ? AND user_id = ?
      `);
            const insertStmt = db.prepare(`
        INSERT INTO timeline_photos (timeline_id, file_path, description, display_order, created_at)
        VALUES (?, ?, ?, ?, datetime('now'))
      `);
            for (let idx = 0; idx < photoIds.length; idx++) {
                const photoId = photoIds[idx];
                const photo = photoStmt.get(photoId, user.userId);
                if (photo) {
                    const result = insertStmt.run(timelineId, photo.file_path, photo.description, idx);
                    insertedPhotos.push({
                        id: result.lastInsertRowid,
                        file_path: photo.file_path,
                        description: photo.description,
                        display_order: idx
                    });
                    console.log('âœ… Photo linked - photoId:', photoId, 'timelineId:', timelineId);
                }
                else {
                    console.warn('âš ï¸ Photo not found or not owned by user - photoId:', photoId);
                }
            }
        }
        // ãƒ‘ã‚¿ãƒ¼ãƒ³2: ç›´æ¥å†™çœŸãƒ‡ãƒ¼ã‚¿ã§ç´ä»˜ã‘ã‚‹
        if (photoData && Array.isArray(photoData) && photoData.length > 0) {
            const insertStmt = db.prepare(`
        INSERT INTO timeline_photos (timeline_id, file_path, description, display_order, created_at)
        VALUES (?, ?, ?, ?, datetime('now'))
      `);
            for (let idx = 0; idx < photoData.length; idx++) {
                const photo = photoData[idx];
                const result = insertStmt.run(timelineId, photo.file_path, photo.description || '', idx);
                insertedPhotos.push({
                    id: result.lastInsertRowid,
                    file_path: photo.file_path,
                    description: photo.description || '',
                    display_order: idx
                });
                console.log('âœ… Photo data linked - timelineId:', timelineId);
            }
        }
        res.status(201).json({
            success: true,
            message: `${insertedPhotos.length} photos linked successfully`,
            data: insertedPhotos
        });
    }
    catch (error) {
        console.error('âŒ Error:', error);
        res.status(500).json({ error: error.message });
    }
});
// DELETE /api/timeline/:timelineId/photos/:photoId - ç´ä»˜ãã‚’å‰Šé™¤
router.delete('/:timelineId/photos/:photoId', authenticate, (req, res) => {
    try {
        const { timelineId, photoId } = req.params;
        const user = req.user;
        const db = getDb();
        console.log('ğŸ—‘ï¸ Unlink photo - timelineId:', timelineId, 'photoId:', photoId);
        // æœ¬äººç¢ºèª
        const timeline = db.prepare('SELECT user_id FROM timeline WHERE id = ?').get(timelineId);
        if (!timeline || timeline.user_id !== user.userId) {
            console.error('âŒ Access denied');
            return res.status(403).json({ error: 'ã‚¢ã‚¯ã‚»ã‚¹æ¨©é™ãŒã‚ã‚Šã¾ã›ã‚“ã€‚' });
        }
        const stmt = db.prepare('DELETE FROM timeline_photos WHERE id = ? AND timeline_id = ?');
        stmt.run(photoId, timelineId);
        console.log('âœ… Photo unlinked successfully');
        res.json({
            success: true,
            message: 'Photo unlinked successfully'
        });
    }
    catch (error) {
        console.error('âŒ Error:', error);
        res.status(500).json({ error: error.message });
    }
});
// ============================================
// POST /api/timeline/:timelineId/metadata - timeline_metadata ä½œæˆ
// ============================================
router.post('/:timelineId/metadata', authenticate, (req, res) => {
    try {
        const user = req.user;
        const db = getDb();
        const { timelineId } = req.params;
        const { user_id, important_events, turning_points, custom_metadata } = req.body;
        console.log('ğŸ“Š timeline_metadata creation request:', {
            userId: user.userId,
            timelineId,
            hasImportantEvents: !!important_events,
            hasTurningPoints: !!turning_points
        });
        // user_id ã®æ¤œè¨¼
        if (user_id !== user.userId) {
            console.error('âŒ User ID mismatch');
            return res.status(403).json({ error: 'ã‚¢ã‚¯ã‚»ã‚¹æ¨©é™ãŒã‚ã‚Šã¾ã›ã‚“' });
        }
        // timeline ãŒå­˜åœ¨ã™ã‚‹ã‹ç¢ºèª
        const timeline = db.prepare('SELECT * FROM timeline WHERE id = ? AND user_id = ?').get(timelineId, user.userId);
        if (!timeline) {
            console.error('âŒ Timeline not found');
            return res.status(404).json({ error: 'Timeline ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“' });
        }
        // âœ… timeline_metadata ã«æŒ¿å…¥ï¼ˆæ—¢å­˜ã®å ´åˆã¯ç„¡è¦–ã€æ–°è¦ã®å ´åˆã®ã¿ä½œæˆï¼‰
        try {
            const stmt = db.prepare(`
        INSERT INTO timeline_metadata (
          user_id, 
          timeline_id, 
          important_events, 
          turning_points, 
          custom_metadata, 
          created_at
        ) VALUES (?, ?, ?, ?, ?, datetime('now'))
      `);
            stmt.run(user.userId, timelineId, important_events || '[]', // JSONæ–‡å­—åˆ—ã¨ã—ã¦ä¿å­˜
            turning_points || '[]', // JSONæ–‡å­—åˆ—ã¨ã—ã¦ä¿å­˜
            custom_metadata ? JSON.stringify(custom_metadata) : '{}');
            console.log('âœ… timeline_metadata created successfully - timelineId:', timelineId);
            res.json({
                success: true,
                message: 'timeline_metadata created successfully',
                timelineId
            });
        }
        catch (dbError) {
            // UNIQUE åˆ¶ç´„ã«ã‚ˆã‚‹é‡è¤‡ã‚¨ãƒ©ãƒ¼ã®å ´åˆã¯ç„¡è¦–
            if (dbError.message.includes('UNIQUE')) {
                console.log('âš ï¸ timeline_metadata already exists for this timeline');
                return res.json({
                    success: true,
                    message: 'timeline_metadata already exists',
                    timelineId
                });
            }
            throw dbError;
        }
    }
    catch (error) {
        console.error('âŒ Error in POST /api/timeline/:timelineId/metadata:', error);
        res.status(500).json({
            error: 'timeline_metadata ä½œæˆã«å¤±æ•—ã—ã¾ã—ãŸ',
            details: error.message
        });
    }
});
export default router;
//# sourceMappingURL=Oldtimeline.js.map